/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>
#include <string.h>

#include "callbacks.h"
#include "interface.h"
#include "support.h"

#define GLADE_HOOKUP_OBJECT(component,widget,name) \
  g_object_set_data_full (G_OBJECT (component), name, \
    g_object_ref (widget), (GDestroyNotify) g_object_unref)

#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
  g_object_set_data (G_OBJECT (component), name, widget)

gboolean const shape[7][7]={{FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                            {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                            {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE},
                            {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE},
                            {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE},
                            {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                            {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE}}; // Board Shape, TRUE denotes valid fields

  /*************
   *    init   *
   *************/

GdkPixbuf *pixbuf;
gboolean const shape[7][7]; // Board shape
gboolean arr[7][7]; // Array of cells, TRUE denotes filled (active) cells

TCell board[7][7];
TActiveCell activeCell;

gboolean alreadyActive; // variable to make sure that only one button can be active at once

   
gboolean const def[7][7]={{FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                          {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                          {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE},
                          {TRUE, TRUE, TRUE, FALSE,TRUE, TRUE, TRUE},
                          {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE},
                          {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE},
                          {FALSE,FALSE,TRUE, TRUE, TRUE, FALSE,FALSE}}; // Default board, TRUE denotes filled fields

void reset_environment()
 {
  guint8 i,j;
  for(i=0; i<7; ++i)
   {
    for(j=0; j<7; ++j)
     {
      arr[i][j]=def[i][j];
     }
   }  
  alreadyActive=FALSE; // variable to make sure that only one button can be active at once
  
  activeCell.row=7;
  activeCell.col=7;
  
 }

GtkWidget*
create_window1 (void)
{
  GtkWidget *window1;
  GList *icons = NULL;
  GtkWidget *headbar;
  GtkWidget *hbox1;
  GtkWidget *table1;
  /*gboolean fill[7][7]={{FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE},
                       {FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE},
                       {TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE},
                       {TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,TRUE},
                       {TRUE,TRUE,TRUE,TRUE,TRUE,TRUE,TRUE},
                       {FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE},
                       {FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,FALSE}};//*/
  
  GtkWidget *vbox1;
  GtkWidget *button1;
  GtkWidget *btnReset;
  
  GError *err=NULL;
  pixbuf = gdk_pixbuf_new_from_file("ball-green.png",&err);
  g_assert ((pixbuf == NULL && err != NULL) || (pixbuf != NULL && err == NULL));
  if (err != NULL)
    {
      /* Report error to user, and free error */
      g_print("Could not load ball images!\n");
      g_assert (pixbuf == NULL);
      fprintf (stderr, "Unable to read file: %s\n", err->message);
      g_error_free (err);
    } 
  
  // DND ********************************************************************
  GtkTargetEntry targetEntry[1];
  targetEntry[0].target="text/plain";
  targetEntry[0].flags=GTK_TARGET_SAME_APP;
  targetEntry[0].info=0;
  // END DND ****************************************************************

  reset_environment(); // initialize to default values

  window1 = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_title (GTK_WINDOW (window1), "Chinese Checkers");

  GError *error = NULL;
  icons = g_list_append(icons, gdk_pixbuf_new_from_file ("./ball-green-16.png", &error));
  icons = g_list_append(icons, gdk_pixbuf_new_from_file ("./ball-green-32.png", &error));
  icons = g_list_append(icons, gdk_pixbuf_new_from_file ("./ball-green-48.png", &error));
  icons = g_list_append(icons, gdk_pixbuf_new_from_file ("./ball-green-128.png", &error));
  icons = g_list_append(icons, gdk_pixbuf_new_from_file ("./ball-green.svg", &error));
  gtk_window_set_icon_list (GTK_WINDOW (window1), icons);

  // Headerbar:
  headbar = gtk_header_bar_new();
  gtk_header_bar_set_title(GTK_HEADER_BAR(headbar), "Chinese Checkers");
  gtk_header_bar_set_subtitle(GTK_HEADER_BAR(headbar), "Gtk+3 version");
  gtk_header_bar_set_show_close_button(GTK_HEADER_BAR(headbar), TRUE);

  btnReset = gtk_button_new_with_label (_("New"));
  gtk_widget_show (btnReset);

  gtk_header_bar_pack_end(GTK_HEADER_BAR(headbar), btnReset);

  gtk_widget_show(headbar);
  gtk_window_set_titlebar(GTK_WINDOW(window1), headbar);
  // End Headerbar

  hbox1 = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
  gtk_widget_show (hbox1);
  gtk_container_add (GTK_CONTAINER (window1), hbox1);

  table1 = gtk_grid_new(); //gtk_table_new (7, 7, TRUE);
  gtk_grid_set_row_homogeneous (GTK_GRID(table1), TRUE);
  gtk_grid_set_column_homogeneous (GTK_GRID(table1), TRUE);
  gtk_widget_show (table1);
  gtk_box_pack_start (GTK_BOX (hbox1), table1, TRUE, TRUE, 0);
  gtk_container_set_border_width (GTK_CONTAINER (table1), 10);
  gtk_grid_set_row_spacing (GTK_GRID (table1), 2);
  gtk_grid_set_column_spacing (GTK_GRID (table1), 2);
  /* Store pointers to all widgets, for use by lookup_widget(). */
  GLADE_HOOKUP_OBJECT_NO_REF (window1, window1, "window1");
  char toggleLabel[5];
  guint8 i,j;
  for(i=0; i<7; ++i)
   {
   	for(j=0; j<7; ++j)
   	 {
   	  if(shape[i][j])
   	   {
    	   board[i][j].btn = gtk_toggle_button_new();
        // g_assert (pixbuf != NULL);
        if(pixbuf!=NULL) // pixbuf somewhat disappears on windows, hence I provide stock icon there instead
         board[i][j].img = gtk_image_new_from_pixbuf(pixbuf);
        else
         board[i][j].img = gtk_image_new_from_icon_name("gtk-yes",GTK_ICON_SIZE_LARGE_TOOLBAR);
        // DRAG AND DROP PART ********************************************************************
        
        gtk_drag_source_set(board[i][j].btn,
                            GDK_BUTTON1_MASK,
                            targetEntry,
                            sizeof(targetEntry)/sizeof(GtkTargetEntry),
                            GDK_ACTION_MOVE);
        gtk_drag_dest_set(board[i][j].btn,
                          GTK_DEST_DEFAULT_MOTION | GTK_DEST_DEFAULT_HIGHLIGHT | GTK_DEST_DEFAULT_DROP,
                          targetEntry,
                          sizeof(targetEntry)/sizeof(GtkTargetEntry),
                          GDK_ACTION_MOVE);
        if(pixbuf!=NULL) // pixbuf somewhat disappears on windows, hence I provide stock icon there instead
         gtk_drag_source_set_icon_pixbuf(board[i][j].btn, pixbuf);
        else
         gtk_drag_source_set_icon_name(board[i][j].btn, "GTK_STOCK_YES");
        
        g_signal_connect((gpointer) board[i][j].btn, "drag_motion",
                           G_CALLBACK(DNDDragMotionCB), board[i][j].img);
        g_signal_connect((gpointer) board[i][j].btn, "drag_begin",
                           G_CALLBACK(DNDBeginCB), (gpointer) pixbuf);
        g_signal_connect((gpointer) board[i][j].btn, "drag_end",
                           G_CALLBACK(DNDEndCB), (gpointer) window1);
        g_signal_connect((gpointer)board[i][j].btn, "drag_data_get",
                           G_CALLBACK(DNDDataRequestCB), board[i][j].img);
        g_signal_connect((gpointer)board[i][j].btn, "drag_data_received",
                           G_CALLBACK(DNDDataRecievedCB), board[i][j].img);
        g_signal_connect((gpointer)board[i][j].btn, "drag_data_delete",
                           G_CALLBACK(DNDDataDeleteCB), board[i][j].img);
                
        // END OF DND ****************************************************************************
        board[i][j].row = i;
        board[i][j].col = j;
        //// gtk_widget_set_size_request (board[i][j].btn, 44, 44);
        //gtk_misc_set_padding(GTK_MISC(board[i][j].img),0,0);
        gtk_container_add (GTK_CONTAINER (board[i][j].btn), board[i][j].img);
        if(!arr[i][j])
         {
          gtk_widget_set_sensitive(board[i][j].btn, FALSE);
          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(board[i][j].btn), TRUE);
         }
        else
         {
          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(board[i][j].btn), FALSE);
          gtk_widget_show (board[i][j].img);
         }
        gtk_widget_show(board[i][j].btn);
    	   /*gtk_grid_attach(GTK_GRID(table1),board[i][j].btn,j,j+1,i,i+1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);*/
			gtk_grid_attach(GTK_GRID(table1),board[i][j].btn,j,i,1,1);
        g_signal_connect((gpointer) board[i][j].btn, "toggled",
                         G_CALLBACK (cell_changed),
                         (gpointer) window1);
        sprintf(toggleLabel,"b%d_%d",i+1,j+1);
        GLADE_HOOKUP_OBJECT (window1, board[i][j].btn, toggleLabel);
   	   }
   	  
   	 }
   }//*/
  // SIDEPANEL REMOVED BEING UNNECESSARY IN GTK3 ALONG WITH HEADERBAR:
  // vbox1 = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2); //gtk_vbox_new (FALSE, 2);
  // gtk_widget_show (vbox1);
  // gtk_box_pack_start (GTK_BOX (hbox1), vbox1, TRUE, TRUE, 0);
  // gtk_container_set_border_width (GTK_CONTAINER (vbox1), 10);

  // button1 = gtk_button_new_with_label (_("Quit"));
  // gtk_widget_show (button1);
  // gtk_box_pack_end (GTK_BOX (vbox1), button1, FALSE, FALSE, 0);

  // btnReset = gtk_button_new_with_label (_("New"));
  // gtk_widget_show (btnReset);
  // gtk_box_pack_end (GTK_BOX (vbox1), btnReset, FALSE, FALSE, 0);

  g_signal_connect(G_OBJECT(window1),"destroy",G_CALLBACK(destroy),NULL);
  g_signal_connect(G_OBJECT(window1),"delete_event",G_CALLBACK(delete_event),NULL);
  
  g_signal_connect ((gpointer) button1, "button_release_event",
                    G_CALLBACK (on_button1_button_release_event),
                    NULL);

  g_signal_connect ((gpointer) btnReset, "button_release_event",
                    G_CALLBACK (on_btnReset_release_event),
                    NULL);

  GLADE_HOOKUP_OBJECT (window1, hbox1, "hbox1");
  GLADE_HOOKUP_OBJECT (window1, table1, "table1");
  GLADE_HOOKUP_OBJECT (window1, vbox1, "vbox1");
  GLADE_HOOKUP_OBJECT (window1, button1, "button1");

  return window1;
}

